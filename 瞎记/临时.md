## 10.31

### T1

可以线段树模拟，区间加、区间赋值、区间求和。有点卡常。

更优秀的做法是，每次操作会删去若干空格、产生一个空格，用一个栈模拟，同时记录位置和空格长度来计算贡献。

### T2

对于每种结果对应的区间集合，我们再最小的区间统计贡献。

补集转化一下，求无贡献的区间，充要条件为：左端点是区间最小值或者右端点是区间最大值。

单调栈可以求出满足其中之一的。为了不算重两者都满足的，在统计后者的时候同时再维护一个单调栈，用来求某个区间内是区间最小值的左端点数。

### T3

长为 $b+1$ 的合法区间中有且仅有一个数出现两次。

滑动这个区间，弹出的数若只出现一次，新加入的数只能与其相等；若出现两次，新加入的数任意。

那么记录重复的数的第一次出现次数，可以有 $\mathcal O(n^2)$ 的 DP。

观察 $f(i,*)\to f(i+1,*)$ 的转移过程，发现是整体平移和近似的全局加，用队列和一个全局加标记模拟即可 $\mathcal O(n)$。

### T4

每次询问都计算一遍，枚举强制经过的边统计方案数进行暴力容斥，没啥思维水平。

有大量细节，大概是：不要算上大小为 $2$ 的环；由于翻转同构最后要 $\div 2$；注意判出现环和所有边构成一个环的情况。

复杂度 $\mathcal O(m^22^m)$。
