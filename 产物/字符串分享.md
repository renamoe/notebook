---
marp: true
---

![bg right:60%](https://s1.ax1x.com/2020/10/24/BVZhjS.png)

# 串串题瞎分享

RenaMoe

---

需不需要回顾一下扩展 KMP？

很好学的，和 manachar 一个原理。

---

## HDU#6153. A Secret

给你串 $S,T$，求 $T$ 每个后缀在 $S$ 中的出现次数。

复杂度要求线性。

---

方向一定是，先把两个串翻过来，对 $T$ 构建 $\mathrm{fail}$ 数组，做 KMP。

怎么统计答案？

---

KMP 匹配的过程，是不是 $T$ 的一个前缀在 $S$ 某一个位置匹配。

而 $T$ 的一个前缀 $T'$ 被匹配，那么 $T'$ 的所有 $\mathrm{Border}$ 也都会被匹配。

---

打一个差分标记，然后倒着下放标记。

本质上是 $\mathrm{fail}$ 树上的链加。

---

## S2OJ#379. 最长重复子串

定义一个串 $T$ 为重复字串，当且仅当 $T$ 由一个长为 $\frac{|T|}{2}$ 串重复得到（$|T|$ 为偶数）。

例如：$\texttt{aa}$，$\texttt{abcabc}$。

给出串 $S$，若 $S$ 的子串 $T$ 满足 $T$ 是重复子串，求 $|T|$ 最长是多少。

$|S|\le 10^6$。

---

首先分治，考虑所有跨过分治中心 $\mathrm{mid}$ 的子串 $S_{l\dots r}$。

设 $l\dots r$ 中点为 $m$，观察各个段之间的相等关系，以 $m\le \mathrm{mid}$ 为例：

![](https://z3.ax1x.com/2021/10/08/59LItx.png)

---

![w:500](https://z3.ax1x.com/2021/05/24/gxFDnU.png)

设 $r-l+1=2L$，可以列出形式化的式子：

$$
\begin{cases}
\mathrm{mid}-m\le\mathrm{LCS}(\mathrm{mid}-L,\mathrm{mid})\\
r-\mathrm{mid}\le\mathrm{LCP}(\mathrm{mid}-L+1,\mathrm{mid}+1)
\end{cases}
$$


---

那么枚举 $L$，尝试去判断 $L$ 是否合法。

那么式子中就不能出现 $l,m,r$，把两个式子相加得到：

$$
L\le \mathrm{LCS}(\mathrm{mid}-L,\mathrm{mid})+\mathrm{LCP}(\mathrm{mid}-L+1,\mathrm{mid}+1)
$$

怎么求 $\mathrm{LCS},\mathrm{LCP}$？

---


$$
L\le \mathrm{LCS}(\mathrm{mid}-L,\mathrm{mid})+\mathrm{LCP}(\mathrm{mid}-L+1,\mathrm{mid}+1)
$$

式子中 $\mathrm{mid}$ 为定值。

那么可以分治中每层**扩展 KMP** 通过 $\mathcal O(\text{分治区间长度})$ 处理得到，

- $\mathrm{mid}$ 结尾的前缀和每个前缀的 $\mathrm{LCS}$；
- $\mathrm{mid}+1$ 开头的后缀和每个后缀的 $\mathrm{LCP}$。

那么本题 $\mathcal O(n\log n)$ 解决。

---

## CF1535F. String Distance

给出 $n$ 个长度为 $m$ 的串 $s_i$。

对于两个串 $S,T$，选取其中一个串中的一个区间进行排序称为一次操作，$f(S,T)$ 表示使得 $S,T$ 相同的最少操作次数。

如果 $S$ 无法变成 $T$，那么 $f(S,T)=114514$。

求 $\sum_{i=1}^n\sum_{j=i+1}^nf(s_i,s_j)$。

$n\times m\le 2\times 10^5$。

---

观察到 $n\times m\le 10^5$，你可以想到根号分治，然后套上一些高级字符串数据结构，也是可以做的。但是太不优雅了！

讲个优雅的做法，只用基础算法。

---

首先只有字符种类的数量相同的两个串，才能通过若干次操作变得相同。

所以我们把这些串按字符种类，分成若干个集合。

不同集合之间的答案是可以直接算的。

分别处理每个集合内的答案。

---

小结论：对于同一集合的两个串 $S,T$，$f(S,T)$ 至多为 $2$。

因为可以把两个串都全部排序。

答案上界这么小，做一些分类讨论吧！

---

$S,T$ 相同的部分可以不管。

设一个区间 $[l,r]$，满足 $S_{l\dots r}\not=T_{l\dots r}$ 且 $S_{0\dots l-1}=T_{0\dots l-1}$, $S_{r+1\dots m}=T_{r+1\dots m}$，那么

- 一般情况只需要对两个串的 $[l,r]$ 区间分别排序，操作次数最多为 $2$；
- 如果其中一个串的 $[l,r]$ 区间原本就是有序的，操作次数为 $1$；
- 如果 $S=T$，不存在这样的区间，操作次数为 $0$。

只要统计第二、三种情况的答案就好了。

---

第三种情况只要统计相同的字符串对数，很容易。

---

第二种情况，串对 $(S,T)$ 产生贡献的条件是，$S$ 存在一个有序区间 $[l,r]$，$T$ 满足除了 $[l,r]$ 以外的部分相同。

那么对于串对 $(S,T)$ 我们可以固定一个尽量长的前缀 $[1,l-1]$ 相同，

然后让 $S$ 的有序区间 $[l,r]$ 尽可能长（为了匹配到的 $T$ 更多），

看 $T$ 是否满足 $[r+1,m]$ 部分和 $S$ 相同。

---

把一个集合里的所有字符串按字典序排序，记为 $a_{1\dots n}$，设他们的长度均为 $m$。

用 $\texttt{std::string}$ 存字符串，然后 $\texttt{std::sort}$，这样的复杂度是 $\mathcal O(nm\log n)$ 的。

排序后，有了这样的性质：

- 两两相邻的点求 $\mathrm{LCP}$，那么任意两个串的 $\mathrm{LCP}$ 就是区间最小值；
- 对于区间 $[1,l-1]$ 相同的若干个串，$[l,r]$ 有序的串一定排在前面。

---

排序后对于每个串 $S=a_i$，和 $T=a_{i+1\dots n}$ 匹配进行统计。

基于排序的性质，$a_i$ 与 $a_{i+1\dots n}$ 的 $\mathrm{LCP}$ 是单调不降的。

通过单调栈，可以把 $a_{i+1\dots n}$ 按 $\mathrm{LCP}$ 划分成 $\mathcal O(m)$ 段。

逐个考虑每个段，配对的规模是 $\mathcal O(nm)$ 的。

---

现在我们固定了相同的前缀，然后我们找到串 $a_i$ 从 $l$ 开始最长的有序区间 $[l,r]$。

可以预处理然后每次二分得到。

现在只要看这前缀相同的这一段字符串中有多少满足 $[r+1,m]$ 相同。

---

我们倒着看这些串，她们是乱序的。

要固定一个后缀相同，需要用 **trie 树**来匹配。

先把所有串都插入 trie 中。

找到 $a_i$ 第 $r+1$ 个字符在 trie 中的位置，看这一段中有多少个串经过这个点即可。 

插入 trie 的时候记录字符所在节点和经过节点的所有串编号就好了。

---

复杂度 $\mathcal O(nm(\log n+\log m))$。

---

谢谢大家。

