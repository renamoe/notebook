## LOJ#3103. 「JSOI2019」节日庆典

[link](https://loj.ac/p/3103)

考虑维护最小的后缀集合。

每次末尾加入字符 $s_i$，对于候选集合的任意两个后缀 $j,k$，只需要比较 $s_{j+i-k},s_i$ 的关系，若不同则留下较优的。

对于候选集合中 $i,j$，假设两者的 $\mathrm{LCP}$ 有重合部分，则有如图所示的相等关系：

![](https://s4.ax1x.com/2022/01/16/7twmWt.png)

那么讨论 $ABC,BCA$ 的大小关系，

- 若 $ABC< BCA$，则 $T_i< T_j< T_k$；
- 若 $ABC> BCA$，则 $T_i> T_j> T_k$；

可以发现 $j$ 无论如何都不可能成为答案，所以候选集合任意两者的 $\mathrm{LCP}$ 不重合。

那么从右往左，相邻两个候选点的距离翻倍，任意时刻候选集合大小是 $\mathcal O(\log n)$ 的。可以每次暴力重构。

最后从候选集合中查询答案时，需要比较整串和某个后缀的的字典序，exkmp 预处理 $\mathrm Z$ 函数即可。

复杂度 $\mathcal O(n\log n)$。

[submission(1)](https://loj.ac/s/1348941)


## LOJ#6041. 「雅礼集训 2017 Day7」事情的相似度

[link](https://loj.ac/p/6041)

两个前缀的 LCS 就是 SAM 的 parent 树上的 LCA 节点的 $\mathrm{len}$。

在 parent 树上枚举 LCA，任何统计跨过 LCA 的点对的贡献，由于是查询区间最大点对，所以只有不同子树内并且位置相邻的点对是有用的，那么用 $\texttt{std::set<>}$ 维护位置集合然后启发式合并。

最后离线询问，就是二维数点问题。

[submission(1)](https://loj.ac/s/1349276)

当然也可以直接用 LCT 维护 parent 树，扫描线每次加入一个字符后给其节点到根的路径都打上时间戳，access 时两条时间戳不同的链的交点，就是两个时间戳代表前缀的 LCA。后面同理。

