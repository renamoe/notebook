

## CF908D. New Year and Arbitrary Arrangement

[link](https://codeforces.com/problemset/problem/908/D)

初始想法是 DP 状态记录 $\texttt{ab}$ 对儿数和 $\texttt{a}$ 数量，记为 $f(i,j)$，但是可能存在 $\texttt{ab}$ 对儿数 $<k$ 但是末尾有大量 $\texttt{a}$ 的状态，这样复杂度是爆炸的。

观察性质，状态 $f(i,j)$ 如果 $i<k$ 但是 $i+j\ge k$，那么再放一个 $\texttt{b}$ 就会满足。那么只要算下一次出现 $\texttt{b}$ 的期望步数，此时 $f(i,j)=i+j+\frac{1}{P_b}-1$。

写记忆化搜索会很方便。

[submission(0)](https://codeforces.com/contest/908/submission/130460112)

## LOJ#2673. 「NOI2012」迷失游乐园

[link](https://loj.ac/p/2673)

先想树的做法。对于一条路径一定是从终点往起点 DP，而在树上的一条路径可以分成上行和下行两部分，设为 $f,g$，转移：

$$
f(u)=\frac{1}{d(u)}\sum_{v\in \mathrm{son(u)}} (f(v)+w(u,v))
$$


$$
g(u)=\frac{1}{d(u)}(w(u,\mathrm{fa})+\frac{d(\mathrm{fa})\cdot(g(\mathrm{fa})+f(\mathrm{fa}))-f(u)-w(u,\mathrm{fa})}{d(\mathrm{fa})-1})
$$

对于基环树，路径至多会经过环一段连续部分，环很小，直接暴力枚举起终点，可以算出环上每个点向环上走的答案，也就是 $g$。那么先 DP 树上的 $f$，再处理环上的 $g$，再 DP 树上的 $g$ 即可。

[submission(3)](https://loj.ac/s/1267776)

## CF235D. Graph Game

[link](https://codeforces.com/problemset/problem/235/D)

考虑对于每个点 $u$ 为“重心”求连通块大小，那么 $v$ 被计算到的概率，也就是 $u\to v$ 路径在之前不被断开，并且此时在 $u$ 处断开的概率。

对于树，对于任何一个点对 $(u,v)$ 的贡献就是 $\frac{1}{\mathrm{dis}(u,v)}$。

对于基环树，路径经过环的点对特殊计算：

![](https://z3.ax1x.com/2021/10/07/5Suzge.png)

那么就要分两种情况：

- 第一次就删去 $u$，那么概率为 $\frac{1}{x+y+z}$；
- 先删掉环上一点，再删去 $u$，那么概率为 $\frac{y}{x+y+z}\cdot \frac{1}{x+z}+\frac{z}{x+y+z}\cdot \frac{1}{x+y}$；

那么可以直接枚举点对计算，加上倍增求 $\mathrm{LCA}$，复杂度 $\mathcal O(n^2\log n)$。

[submission(0)](https://codeforces.com/contest/235/submission/131019872)

## P5249 [LnOI2019]加特林轮盘赌

[link](https://www.luogu.com.cn/problem/P5249)

人相对于加特林是“循环队列”的形式，设 $f(i,j)$ 表示总共 $i$ 个人中第 $j$ 个人最后 win 的概率，转移

$$
f(i,j)=p\times f(i-1,j-1)+(1-p)\times f(i,j-1)
$$

但是我们并不知道 $f(i,0)$ 是多少，而照定义转移的话是成环的。因为 $\sum_{j}f(i,j)=1$，那么可以列方程求解，设 $f(i,0)=x$，$f(i,j)$ 就都可以表示为 $kx+b$ 的形式。从小到大枚举 $i$ 就可以推出每一行，复杂度 $\mathcal O(n^2)$。

注意 $p=0$ 的情况！

[code(2)](https://gitee.com/renamoe/pastebin/blob/master/LuoguP5249.cpp)


## P4223 期望逆序对

[link](https://www.luogu.com.cn/problem/P4223)

考虑求每个数对的贡献。

对于数对 $(A,B)$ 需要知道 $k$ 次交换后的位置关系。其他任意位置对于 $(A,B)$ 都是等价的，视为 $C$。那么只要 DP 求出 $(A,B)$ $k$ 次交换后变为 $(A,B),(B,A),(A,C),(C,A),(B,C),(C,B),(C,C)$ 的方案数，改为矩阵转移即可 $\mathcal O(\log k)$ 求出。

然后求 $(A,B)$ 在每一种情况下可能成为逆序对的方案数，具体见 [Yukikaze_ 的题解](https://www.luogu.com.cn/blog/_post/269050) 和代码，用树状数组可以做到 $\mathcal O(n\log n)$。

[code(3)](https://gitee.com/renamoe/pastebin/blob/master/LuoguP4223.cpp)


