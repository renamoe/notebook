## ARC125D - Unique Subsequence

[link](https://atcoder.jp/contests/arc125/tasks/arc125_d)

DP 设 $f(i)$ 表示 $i$ 结尾的合法子序列个数。每个数字只在最后一次出现时的 $f$ 值是有效的。

发现对于子序列 $a_{p_1}\dots a_{p_k}$，任意两个相邻的数 $a_{p_i}$ 和 $a_{p_{i+1}}$ 之间不能存在等于 $a_{p_i}$ 或 $a_{p_{i+1}}$ 的数，否则非法。

那么转移时，强制每个数 $a_i$ 从上一次出现的位置 $\mathrm{last}(a_i)\dots i-1$ 转移，并且任何时刻每个数字只在最后一次出现的位置保留 $f$ 值，可以用树状数组维护。

[submission(0)](https://atcoder.jp/contests/arc125/submissions/25514677)

## CF468D. Tree

[link](https://codeforces.com/contest/468/problem/D)

$$
\sum_{i=1}^n\mathrm{dis}(i,p_i)=\sum_{i=1}^n\mathrm{dis}(\mathrm{root},i)+\mathrm{dis}(\mathrm{root},p_i)-\mathrm{dis}(\mathrm{root},\mathrm{LCA}(i,p_i))
$$

也就是最小化 $\sum_i\mathrm{dis}(\mathrm{root},\mathrm{LCA}(i,p_i))$。

最好的情况当然是 $\mathrm{LCA}(i,p_i)=\mathrm{root}$，而以重心为 $\mathrm{root}$ 恰好能满足。因为任何一个子树大小不超过 $\lfloor\frac n2\rfloor$。

一个方便的构造方式是，在 dfs 序上每个点 $d_i$ 向 $d_{i+\lfloor\frac n2\rfloor}$ 配对，即可保证任意一对不在同一棵子树。

然后是保证字典序最小。从小到大依次满足，每次第 $i$ 个点找到子树外编号最小的点配对。

但是可能会出现某时刻不得不在同一子树内配对的情况。我们把每个点拆成入和出两个点，每个子树 $i$ 入点数 $f_i$，出点数 $g_i$，不合法的条件为存在子树 $g_i>\sum_{j\neq i} f_j$。

为了避免这种情况，当某一时刻存在某个子树 $i$ 满足 $g_i=\sum_{j\neq i} f_j$ 也就是 $f_i+g_i=\text{剩余入点数}$ 时，就一定要选 $i$ 子树。

我们用若干 $\texttt{std::set<>}$ 来实现，注意特殊讨论根。

[submission(1)](https://codeforces.com/contest/468/submission/128905288)

## ARC015D - Let's Play Nim

[link](https://atcoder.jp/contests/arc105/tasks/arc105_d)

考虑石子堆的异或和。$n$ 的奇偶性关系到最后做 nim 游戏的先后手，分类讨论：

- $n$ 为偶数，先手加入石子堆时要尽量让异或和不为 $0$。如果石子堆可以两两配对相等的话，后手就可以复刻先手的动作从而先手必败。否则先手可以一直掌握最大的石子堆：每次挑最大的石子堆加入同一盘子，可以保证该盘严格大于其它石子堆和，异或和不为 $0$。
- $n$ 为奇数，先手要尽量让异或和为 $0$。但是后手有同样的掌握最大石子堆的策略，先手必败。

## ARC105E - Keep Graph Disconnected

[link](https://atcoder.jp/contests/arc105/tasks/arc105_e)

终止局面一定是 $n$ 个点分为两个连通块 $a,b$，总步数就是 $\frac{n\times (n-1)}{2}-a\times b-m$。

总步数的奇偶性决定先后手的胜负。因为 $a+b=n$，我们讨论 $n$ 的奇偶性：

- $n$ 为奇数：$a\times b$ 一定是偶数，总步数奇偶性直接确定。
- $n$ 为偶数：考虑操作过程对 $a\times b$ 奇偶性的影响，设一开始 $1,n$ 所在连通块大小分别为 $x,y$，每次操作可以通过将奇数大小的连通块于其中之一连接，来改变奇偶性。
  - $x,y$ 奇偶性相同：可以推出奇数大小连通块数为偶数个，操纵奇数大小连通块的策略会两两抵消，奇偶性不会改变；
  - $x,y$ 奇偶性不同：可以推出奇数大小连通块数为奇数个，先手可以第一步通过操纵奇数大小连通块，将 $a\times b$ 变成奇数或者偶数，后续同上，先手必胜。

[submission(1)](https://atcoder.jp/contests/arc105/submissions/25880016)

## ARC066B - Xor Sum

[link](https://atcoder.jp/contests/abc050/tasks/arc066_b)

观察性质：因为异或是不进位加法，所以 $a+b=(a\operatorname{and} b)\times 2+(a\operatorname{xor}b)$，即 $u\le v$。我们对每个 $v$ 去统计可配对的 $u$。

可以发现 $u,v$ 唯一对应一对 $a,b$ $(a < b)$。逐位考虑 $a,b$，最低位有 $(0,0),(0,1),(1,1)$ 三种情况，我们去掉其贡献，那么可以递归的考虑剩余位，这样只递归 $\log$ 次。

具体地，我们可以列出转移，

$$
f(k)\gets \begin{cases}
f(\frac k2)+f(\frac{k-2}{2})&2\mid k\\
f(\frac{k-1}{2})&2\not\mid k
\end{cases}
$$

然后我们对 $f$ 做前缀和，推式子可以得到非常简洁的式子：

$$
s(k)=s(\lfloor\frac{k}{2}\rfloor)+s(\lfloor\frac{k-1}{2}\rfloor)+s(\lfloor\frac{k-2}{2}\rfloor)
$$

## Luogu P3960 [NOIP2017 提高组] 列队

[link](https://www.luogu.com.cn/problem/P3960)

若只操作一行一列，问题便是删除第 $k$ 个数、末尾插入一个数，平衡树、线段树都可。

$n\times m$ 的网格中，发现变动很大的只有最后一列，拿出来分开考虑。每一行（和最后一列）总共只有 $Q$ 次删除和末尾插入，对于不被改动的连续段，不需要显式的维护，考虑用动态开点线段树维护。

难度在于代码细节，仔细考虑推算线段树节点 $\mathrm{size}$ 和叶子权值的部分。

[code(2)](https://gitee.com/renamoe/pastebin/blob/master/LuoguP3960.cpp)

## ARC104E - Random LIS

[link](https://atcoder.jp/contests/arc104/tasks/arc104_e)

求 LIS 我们需要知道数之间的相对大小关系，$N$ 很小所以考虑直接枚举所有 $N!$ 个情况。

枚举排列 $p_1\dots p_N$ 表示 $a_{p_1}(<\mathrm{or}\le)a_{p_2}(<\mathrm{or}\le)a_{p_3}\dots a_{p_N}$。由于这里 LIS 是严格递增的，我们枚举的排列是按双关键字（权值、下标）排序的：如果 $p_i<p_{i+1}$，那么要让 $a_{p_i}$ 能贡献到 $a_{p_{i+1}}$，一定是 $a_{p_i}< a_{p_{i+1}}$；否则 $a_{p_i}\le a_{p_{i+1}}$。

将所有数按 $p$ 从小到大排列。为了方便我们将 $<$ 统一成 $\le$，也就是将 $<$ 后面的数取值范围减小 $1$。然后将取值范围做后缀 $\min$，记为 $\{h_i\}$，现在问题转化为求满足 $1\le a_i\le h_i$ 且 $a_i\le a_{i+1}$ 的序列 $\{a_i\}$ 方案数。

对于 $\le$ 的关系可以想到格路计数（网格图中每次向右或向上走一步，向右走一步代表结尾填一个数），$h_i$ 的限制可以容斥处理。设 $f_i$ 表示网格图中前 $i$ 条竖线合法方案数，然后去枚举第一次超出限制的位置进行容斥，

$$
f_i\gets {h_i-1+i-1\choose i-1}-\sum_{j < i}{h_i-h_j-1+i-j\choose i-j}f_j
$$

组合数均为 ${x+y\choose y}$ 的形式，可以 $\mathcal O(y)$ 计算。总复杂度 $\mathcal O(N!N^3)$。

[submission(4)](https://atcoder.jp/contests/arc104/submissions/26060672)

## CF264D. Colorful Stones

[link](https://codeforces.com/contest/264/problem/D)

这种二元组状态转移的问题可以放在网格图上，可以根据转移画出这样的图。

![](https://z3.ax1x.com/2021/09/24/4046ht.png)

可以猜测可到达的状态有这样一个大体的界，可以双指针 $\mathcal O(n)$ 计算。

界中也有若干不可到达的点，当且仅当 $\texttt{AB}$ 和 $\texttt{BA}$ 对应时产生，对每种可能的状态做前缀和即可。

[submission(1)](https://codeforces.com/contest/264/submission/129680644)


## Luogu P4484 \[BJWC2018\]最长上升子序列

[link](https://www.luogu.com.cn/problem/P2081)

$n$ 很小考虑状压。

设 $i$ 结尾最长上升子序列长度为 $f_i$，其前缀最大值为 $g_i$，那么容易得到相邻数之差 $g_{i+1}-g_i\le 1$。

状压 $g$ 的差分数组，一个状态对应得最长上升子序列就是 $1$ 的个数。

对于排列考虑按权值从小到大插入。每次插入当前最大值到 $i$ 位置后，那么一定会让 $g'_{i+1}=g_i+1$，并且后面连续一段相同的值 $+1$，反映到差分数组上就是让后面第一个 $1$ 变成 $0$。

那么可以做 $\mathcal O(n^22^n)$ 的 DP。实现上可以少状压 $1$ 位（因为差分数组第 $1$ 位永远是 $1$），但是只有 $84$ 分。打表就好了。

[code](https://gitee.com/renamoe/pastebin/blob/master/LuoguP4484.cpp)


## Luogu P3185 \[HNOI2007\]分裂游戏

[link](https://www.luogu.com.cn/problem/P3185)

每个石子是一个**独立的游戏**，分别求 SG 函数然后异或起来即可。

求方案数和字典序最小的第一步解可以暴力。

[code(1)](https://gitee.com/renamoe/pastebin/blob/master/LuoguP3185.cpp)


## Luogu P6669 \[清华集训2016\] 组合数问题

[link](https://www.luogu.com.cn/problem/P6669)

$k$ 是较小的质数，想到 Lucas 定理，那么一个组合数可以表示为

$$
{n\choose m}={n\bmod k\choose m\bmod k}\times{\lfloor n/k\rfloor\bmod k\choose \lfloor m/k\rfloor\bmod k}\times\dots
$$

这若干项组合数中如果有一项为 $0$ 那么 ${n\choose m}\bmod k$ 就为 $0$。

那么将 $n,m$ 展开成 $k$ 进制，那么就是计算 $i\le n,j\le m,i\ge j$ 的数对 $(i,j)$ 并且满足 $k$ 进制下存在一位 $i'<j'$ 。那么可以数位 DP。

[code(0)](https://gitee.com/renamoe/pastebin/blob/master/LuoguP6669.cpp)


## CF1152F2. Neko Rules the Catniverse (Large Version)

[link](https://codeforces.com/contest/1152/problem/F2)

$k$ 很小，应该考虑按权值从小到大往序列里插入数，DP 状态记录序列的形态。

题目限制，相邻的数满足 $a_{i-1}+m\ge a_i$。当前要插入的是最大的数 $x$，那么 $x$ 能跟在 $y$ 后面一定要求 $x-y\le m$，否则只能插入到序列开头。

那么状压值域最后 $m$ 位的状态，DP 状态 $f(i,j,s)$ 表示值域 $1\dots i$ 当前序列已有 $j$ 个数，$i-m+1\dots i$ 的状态为 $S$。DP 很容易放到矩阵上，就可以 $\mathcal O((k2^m)^3\log n)$ 解决了。

[submission(0)](https://codeforces.com/contest/1152/submission/131374881)

## LOJ#3256. 「JOI 2020 Final」火灾

取 $\max$ 的操作其实是告诉你，在 $t$ 时刻 $i$ 点的权值为 $a_{i-t\dots i}$ 的区间 $\max$。

先差分询问为两个前缀询问，然后从左到右维护前缀上每个时刻的答案。

维护一个单调栈，那么每加入一个点，其在时间维上的权值按照单调栈里的元素分段。

我们在单调栈弹出一个元素的时候计算它对一个区间内点的贡献，需要区间加等差数列和区间加定值。

然后只要考虑询问右端点 $r$ 时仍在单调栈中的元素。对于 $r-i > t$ 的元素贡献是一段区间的等差数列和一段区间的定值，考虑再次离线下来，建出单调栈树，在上面 DFS 时维护点到根的答案；$r-i\le t$ 的元素应特殊处理，其中只有最靠左的元素有贡献。

有很多细节，注意单调栈开头是缺少一些限制的。

[code(0)](https://loj.ac/s/1271422)。

记录一个叉姐的几何化的做法。

还是观察做单调栈的过程，插入 $i$ 点后的后缀 $\max$ 记为 $f_{i,j}$。按 $i$ 从小到大、$j$ 从左到右看 $f$，此时每个元素会代表一个矩形。

每次查询 $t$ 时刻 $[l,r]$，其实就是在计算线段 $(l,l-t)\to (r,r-t)$ 上所有点的权值和。

考虑转化为二维偏序类似物。将每个矩形差分为四个没有上、左边界的“角”，每个角再按对角线分成两类“角”，将线段差分为两个向右下的射线。两类角对称，做法类似。

角 $(x,y)$ 和射线 $(a,b)$ 配对产生贡献的条件为

$$
\begin{cases}
b\ge y\\
a+b\le x+y
\end{cases}
$$

其贡献为 $w\times(b-y+1)$。做二维偏序即可。

## CF1043F. Make It One

[link](https://codeforces.com/problemset/problem/1043/F)

往集合里每加入一个数，$\gcd$ 质因子种类将会减小 $1$，否则这个数无用。

那么意味着答案至多为 $7$。先从小到大枚举答案 $k$，然后莫反计算 $f(d)$ 表示大小为 $k$ 的 $\gcd=d$ 的集合数量。

较为简单的莫反可以直接容斥，设 $\mathrm{cnt}(d)$ 表示 $d$ 的倍数的个数，

$$
f(d)={\mathrm{cnt}(d)\choose k}-\sum_{i\ge 2}f(i\cdot d)
$$

[submission(0)](https://codeforces.com/contest/1043/submission/131652274)


## Luogu P4707 重返现世

[link](https://www.luogu.com.cn/problem/P4707)

其实是求第 $k$ 小的期望步数。

令 $k\gets n-k+1$，然后套一层 kthmax-min 容斥。

我们要求

$$
\sum_{T\subseteq U}(-1)^{|T|-k}{|T|-1\choose k-1}\frac{m}{\sum_{i\in T}p_i}
$$

数据范围不允许我们指数级枚举，考虑 DP。$\frac{1}{\sum p_i}$ 是难以递推的，那么记录进状态；中间的组合数按递推式展开，那么就需要 DP 出来所有 $k'\in [0,k]$ 的状态。

设 $f(i,j,k)$ 表示前 $i$ 个中选择的元素的 $\sum p_i=j$ 的所有集合 $(-1)^{|T|-k}{|T|-1\choose k-1}$ 之和，转移为

$$
f(i,j,k)\gets f(i-1,j,k)-f(i-1,j-a_i,k)+f(i-1,j-a_i,k-1)
$$

复杂度 $\mathcal O(nm(n-k))$，实现的时候需要滚动数组。

[code(0)](https://gitee.com/renamoe/pastebin/blob/master/LuoguP4707.cpp)

## LOJ#2160. 「POI2011 R2 Day0」保险箱 Strongbox

[link](https://loj.ac/p/2160)

所有可打开的位置都可以表示为一个最小的密码的倍数，也就是我们要求一个最小的数 $d\mid \gcd(a_k,n)$，满足 $d\nmid a_i,\in [1,k-1]$。

令 $g=\gcd(a_k,n)$，枚举 $g$ 的所有约数查看是否合法，复杂度 $\mathcal O(d(n)\cdot k)$，不太行。

考虑每个 $a_i$ 的贡献，会导致 $\gcd(a_i,ｇ)$ 的所有约数不合法。那么在 $\gcd(a_i,ｇ)$ 打标记，从大到小枚举约数的时候，同时枚举 $g$ 的所有质因子进行下放标记。

复杂度 $\mathcal O(\sqrt n+k\log n+d(n)\cdot \omega(n))$。

[code(1)](https://loj.ac/s/1276976)

## Luogu P4657 \[CEOI2017\]Chase

[link](https://www.luogu.com.cn/problem/P4657)

同一路径两个方向的价值不一样，树形 DP $f,g$ 分别表示向上走和向下走的答案，然后拼接。

[code(2)](https://gitee.com/renamoe/pastebin/blob/master/LuoguP4657.cpp)

## Luogu P4786 \[BalkanOI2018\]Election

[link](https://www.luogu.com.cn/problem/P4786)

最优的方案是，从左到右扫，如果前缀和 $< 0$ 就删去当前点；从右往左再做一遍。

那么从左往右删去的点数也就是 $\min \mathrm{pre}_p$，从右往左删去的点数也就是 $\min \mathrm{suf}_q'=\min\{\mathrm{suf}_q-\min \mathrm{pre}_p+\min \mathrm{pre}_{p'< q}\}$。

答案即为

$$
\begin{aligned}
&\quad\min \mathrm{pre}_p+\min\{\mathrm{suf}_q-\min \mathrm{pre}_p+\min \mathrm{pre}_{p'< q}\}\\
&=\min \mathrm{pre}_p+\min\mathrm{suf}_q\quad(p<q)
\end{aligned}
$$

求最大子段和即可。

## LOJ#3545. 「CSP-S 2021」交通规划

[link](https://loj.ac/p/3545)

首先应该想到网络最大流的暴力做法。

对于 $k=2$ 的数据可以平面图转对偶图跑最短路。启发我们在对偶图上考虑。

将关键点之间的空隙在对偶图上的部分看作一个点，其颜色取决于两个关键点的颜色。那么要做的就是 $01$ 和 $10$ 的点两两匹配，用若干最短路划分关键点使得异色点不连通。

最短路之间一定不相交，因为如果相交可以交换某两个点，可以使得答案更优。

只有并列和嵌套，那么一个合法的方案，一定可以找到一个断点断开，变成序列上的括号匹配问题。

对每个虚点为起点跑最短路，然后断环成链区间 DP。复杂度 $\mathcal O(T(k\cdot nm\log (nm)))$。

[submission](https://loj.ac/s/1282185)
