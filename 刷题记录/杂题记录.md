## ARC125D - Unique Subsequence

[link](https://atcoder.jp/contests/arc125/tasks/arc125_d)

DP 设 $f(i)$ 表示 $i$ 结尾的合法子序列个数。每个数字只在最后一次出现时的 $f$ 值是有效的。

发现对于子序列 $a_{p_1}\dots a_{p_k}$，任意两个相邻的数 $a_{p_i}$ 和 $a_{p_{i+1}}$ 之间不能存在等于 $a_{p_i}$ 或 $a_{p_{i+1}}$ 的数，否则非法。

那么转移时，强制每个数 $a_i$ 从上一次出现的位置 $\mathrm{last}(a_i)\dots i-1$ 转移，并且任何时刻每个数字只在最后一次出现的位置保留 $f$ 值，可以用树状数组维护。

[submission(0)](https://atcoder.jp/contests/arc125/submissions/25514677)

## CF468D. Tree

[link](https://codeforces.com/contest/468/problem/D)

$$
\sum_{i=1}^n\mathrm{dis}(i,p_i)=\sum_{i=1}^n\mathrm{dis}(\mathrm{root},i)+\mathrm{dis}(\mathrm{root},p_i)-\mathrm{dis}(\mathrm{root},\mathrm{LCA}(i,p_i))
$$

也就是最小化 $\sum_i\mathrm{dis}(\mathrm{root},\mathrm{LCA}(i,p_i))$。

最好的情况当然是 $\mathrm{LCA}(i,p_i)=\mathrm{root}$，而以重心为 $\mathrm{root}$ 恰好能满足。因为任何一个子树大小不超过 $\lfloor\frac n2\rfloor$。

一个方便的构造方式是，在 dfs 序上每个点 $d_i$ 向 $d_{i+\lfloor\frac n2\rfloor}$ 配对，即可保证任意一对不在同一棵子树。

然后是保证字典序最小。从小到大依次满足，每次第 $i$ 个点找到子树外编号最小的点配对。

但是可能会出现某时刻不得不在同一子树内配对的情况。我们把每个点拆成入和出两个点，每个子树 $i$ 入点数 $f_i$，出点数 $g_i$，不合法的条件为存在子树 $g_i>\sum_{j\neq i} f_j$。

为了避免这种情况，当某一时刻存在某个子树 $i$ 满足 $g_i=\sum_{j\neq i} f_j$ 也就是 $f_i+g_i=\text{剩余入点数}$ 时，就一定要选 $i$ 子树。

我们用若干 `std::set<>` 来实现，注意特殊讨论根。

[submission(1)](https://codeforces.com/contest/468/submission/128905288)

## ARC015D - Let's Play Nim

[link](https://atcoder.jp/contests/arc105/tasks/arc105_d)

考虑石子堆的异或和。$n$ 的奇偶性关系到最后做 nim 游戏的先后手，分类讨论：

- $n$ 为偶数，先手加入石子堆时要尽量让异或和不为 $0$。如果石子堆可以两两配对相等的话，后手就可以复刻先手的动作从而先手必败。否则先手可以一直掌握最大的石子堆：每次挑最大的石子堆加入同一盘子，可以保证该盘严格大于其它石子堆和，异或和不为 $0$。
- $n$ 为奇数，先手要尽量让异或和为 $0$。但是后手有同样的掌握最大石子堆的策略，先手必败。

## ARC105E - Keep Graph Disconnected

[link](https://atcoder.jp/contests/arc105/tasks/arc105_e)

终止局面一定是 $n$ 个点分为两个连通块 $a,b$，总步数就是 $\frac{n\times (n-1)}{2}-a\times b-m$。

总步数的奇偶性决定先后手的胜负。因为 $a+b=n$，我们讨论 $n$ 的奇偶性：

- $n$ 为奇数：$a\times b$ 一定是偶数，总步数奇偶性直接确定。
- $n$ 为偶数：考虑操作过程对 $a\times b$ 奇偶性的影响，设一开始 $1,n$ 所在连通块大小分别为 $x,y$，每次操作可以通过将奇数大小的连通块于其中之一连接，来改变奇偶性。
  - $x,y$ 奇偶性相同：可以推出奇数大小连通块数为偶数个，操纵奇数大小连通块的策略会两两抵消，奇偶性不会改变；
  - $x,y$ 奇偶性不同：可以推出奇数大小连通块数为奇数个，先手可以第一步通过操纵奇数大小连通块，将 $a\times b$ 变成奇数或者偶数，后续同上，先手必胜。

[submission(1)](https://atcoder.jp/contests/arc105/submissions/25880016)

## ARC066B - Xor Sum

[link](https://atcoder.jp/contests/abc050/tasks/arc066_b)

观察性质：因为异或是不进位加法，所以 $a+b=(a\operatorname{and} b)\times 2+(a\operatorname{xor}b)$，即 $u\le v$。我们对每个 $v$ 去统计可配对的 $u$。

可以发现 $u,v$ 唯一对应一对 $a,b$ $(a < b)$。逐位考虑 $a,b$，最低位有 $(0,0),(0,1),(1,1)$ 三种情况，我们去掉其贡献，那么可以递归的考虑剩余位，这样只递归 $\log$ 次。

具体地，我们可以列出转移，

$$
f(k)\gets \begin{cases}
f(\frac k2)+f(\frac{k-2}{2})&2\mid k\\
f(\frac{k-1}{2})&2\not\mid k
\end{cases}
$$

然后我们对 $f$ 做前缀和，推式子可以得到非常简洁的式子：

$$
s(k)=s(\lfloor\frac{k}{2}\rfloor)+s(\lfloor\frac{k-1}{2}\rfloor)+s(\lfloor\frac{k-2}{2}\rfloor)
$$

## P3960 [NOIP2017 提高组] 列队

[link](https://www.luogu.com.cn/problem/P3960)

若只操作一行一列，问题便是删除第 $k$ 个数、末尾插入一个数，平衡树、线段树都可。

$n\times m$ 的网格中，发现变动很大的只有最后一列，拿出来分开考虑。每一行（和最后一列）总共只有 $Q$ 次删除和末尾插入，对于不被改动的连续段，不需要显式的维护，考虑用动态开点线段树维护。

难度在于代码细节，仔细考虑推算线段树节点 $\mathrm{size}$ 和叶子权值的部分。

[code(2)](https://gitee.com/renamoe/pastebin/blob/master/LuoguP3960.cpp)

## ARC104E - Random LIS

[link](https://atcoder.jp/contests/arc104/tasks/arc104_e)

求 LIS 我们需要知道数之间的相对大小关系，$N$ 很小所以考虑直接枚举所有 $N!$ 个情况。

枚举排列 $p_1\dots p_N$ 表示 $a_{p_1}(<\mathrm{or}\le)a_{p_2}(<\mathrm{or}\le)a_{p_3}\dots a_{p_N}$。由于这里 LIS 是严格递增的，我们枚举的排列是按双关键字（权值、下标）排序的：如果 $p_i<p_{i+1}$，那么要让 $a_{p_i}$ 能贡献到 $a_{p_{i+1}}$，一定是 $a_{p_i}< a_{p_{i+1}}$；否则 $a_{p_i}\le a_{p_{i+1}}$。

将所有数按 $p$ 从小到大排列。为了方便我们将 $<$ 统一成 $\le$，也就是将 $<$ 后面的数取值范围减小 $1$。然后将取值范围做后缀 $\min$，记为 $\{h_i\}$，现在问题转化为求满足 $1\le a_i\le h_i$ 且 $a_i\le a_{i+1}$ 的序列 $\{a_i\}$ 方案数。

对于 $\le$ 的关系可以想到格路计数（网格图中每次向右或向上走一步，向右走一步代表结尾填一个数），$h_i$ 的限制可以容斥处理。设 $f_i$ 表示网格图中前 $i$ 条竖线合法方案数，然后去枚举第一次超出限制的位置进行容斥，

$$
f_i\gets {h_i-1+i-1\choose i-1}-\sum_{j < i}{h_i-h_j-1+i-j\choose i-j}f_j
$$

组合数均为 ${x+y\choose y}$ 的形式，可以 $\mathcal O(y)$ 计算。总复杂度 $\mathcal O(N!N^3)$。

[submission(4)](https://atcoder.jp/contests/arc104/submissions/26060672)

## CF264D. Colorful Stones

[link](https://codeforces.com/contest/264/problem/D)

这种二元组状态转移的问题可以放在网格图上，可以根据转移画出这样的图。

![](https://z3.ax1x.com/2021/09/24/4046ht.png)

可以猜测可到达的状态有这样一个大体的界，可以双指针 $\mathcal O(n)$ 计算。

界中也有若干不可到达的点，当且仅当 $\texttt{AB}$ 和 $\texttt{BA}$ 对应时产生，对每种可能的状态做前缀和即可。

[submission(1)](https://codeforces.com/contest/264/submission/129680644)


## CF908D. New Year and Arbitrary Arrangement

[link](https://codeforces.com/problemset/problem/908/D)

初始想法是 DP 状态记录 $\texttt{ab}$ 对儿数和 $\texttt{a}$ 数量，记为 $f(i,j)$，但是可能存在 $\texttt{ab}$ 对儿数 $<k$ 但是末尾有大量 $\texttt{a}$ 的状态，这样复杂度是爆炸的。

观察性质，状态 $f(i,j)$ 如果 $i<k$ 但是 $i+j\ge k$，那么再放一个 $\texttt{b}$ 就会满足。那么只要算下一次出现 $\texttt{b}$ 的期望步数，此时 $f(i,j)=i+j+\frac{1}{P_b}-1$。

写记忆化搜索会很方便。

[submission(0)](https://codeforces.com/contest/908/submission/130460112)











