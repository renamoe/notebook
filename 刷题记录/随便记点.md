~~够了够了，我不会再复读题解了。这里只记录一点动机和收获。~~

### CF1450C2. Errich-Tac-Toe (Hard Version)

我们想让每三个格子，强制某两个异色。

不如先按 $(i+j)\bmod 3$ 染色。但直接选定某两类格子异色，所有方案都不一定满足步数限制。

不变量是步数总和，抽屉原理。

### gym102900B. Mine Sweeper II

相邻的异色点连边，局面的权值可以描述为每个白点的度数之和。

发现是二分图，翻转所有点的颜色，权值不变。

类似 CF1450C 利用抽屉原理。

### CF607C. Marbles

如果两串最后有一对相反字符，是无解的。推广一下？

存在两个后缀，形状相同、方向相反。此时相当于一条路径上同时操作位于起点和终点的两个棋子，他们到达目的点必须要相遇，而相遇后怎么操作都无法分离，意味着无解。

如果不存在这样的一对后缀，我们考虑不顾第二个人，先把第一个人运到终点。设此时第二个人在序列上的位置 $x$，那么我们此时再不顾第一个人，把第二个人运到终点，第一个人所在序列上的位置一定 $> x$。于是就有解了。

### CF607D. Power Tree

考虑每个点的贡献，而不是傻傻地套动态 DP。

### CF571E. Geometric Progressions

先质因数分解，转化为高维向量的等差数列求交。

若 $j$ 存在某个 $b_{i,j}=0$，讨论一些无解和唯一解的情况，便不必关心。

剩下的均满足 $b_{i,j}\neq 0$。当存在两个向量 $\vec{b_i},\vec{b_j}$ 不平行时，有不超过一个解。所有向量平行时，可以 excrt 求解。

实现上，只需要考虑任意两维的平行关系。[代码](https://codeforces.com/contest/571/submission/154492653) 细节很多。

### CF1101F. Trucks and Cities

只要知道每辆车加一次油最多需要支持走多远的路。

$f(s,t,r)$ 表示 $s\to t$ 加 $r$ 次油，最小的 $\max\{p_{i+1}-p_i\}$。转移需要枚举上一个加油点，可以发现这是凸的且决策点单调，于是可以 $\mathcal O(n^3)$。

### CF1101G. (Zero XOR Subset)-less

要求划分得到的一个向量组线性无关，不妨做一些初等变换，调整为一些前缀异或和构成的向量组。

### Luogu P5155 [USACO18DEC]Balance Beam P

如果一个点向两边移动都不会更优，称为“结束点”。

对于每个点 $i$ 为起点，一定存在两个结束点 $x,y$，最后会移动到 $x,y$ 其中一个停止。

假设已经确定了 $x,y$，现在需要知道：$[x,y]$ 上等概率向左右移动，到达边界停止，在 $x,y$ 处停止分别的概率是什么？

到 $y$ 停止为例，状态形如 $f_x=0,f_y=1,f_i=\frac 12(f_{i-1}+f_{i+1})$。可以解出 $f_i=\frac{i-x}{y-x}$，这是一条直线！

将所有点对 $(x,y)$ 的答案呈现到图像上，答案在凸包上。

### AGC044E. Random Pawn

和 Luogu P5155 十分类似。

如果移动到了 $A_i$ 最大值，立即结束最优。以此断环为链。

但是转移方程 $f_i=\max(A_i,\frac{f_{i-1}+f_{i+1}}{2}-B_i)$ 的常数 $B_i$ 难以处理。

构造偏移量 $\{C_i\}$，满足 $f_i-C_i=\max(A_i-C_i,\frac{f_{i-1}-C_{i-1}+f_{i+1}-C_{i+1}}{2}+\frac{C_{i-1}+C_{i+1}}{2}-B_i-C_i)$。可以直接递推得到。

### CF1286E. Fedya the Potter Strikes Back

考虑答案增量，每加入一个字符，Border 集合的变化：每个 Border 只会加入和删除一次。

快速找到这些 Border，可以记录每个点 fail 树上最近的祖先，满足下一个字符不匹配。跳 fail 的复杂度也就和删除的 Border 数量一样了。

整体取 min 的操作，也可以利用均摊的性质暴力做。

### CF896E. Welcome home, Chtholly

分块后关注每个块内的值域，发现值域范围 $[L,R]$ 是不断缩小的。

每次选择 $[l,l+x-1]$ 和 $[l+x,R]$ 中较小的区间，把信息加到另一个区间上。复杂度就是所有值域总大小 $\mathcal O(n\sqrt n)$。

由于散块暴力重构需要知道每个数经过若干次修改后是多少，用并查集维护。这种特殊情况下并查集复杂度是均摊 $\mathcal O(1)$ 的。

### CF632F. Magic Matrix

这是个邻接矩阵。条件可以转化为每条边 $(i,j)$ 的边权，都不超过所有的 $i\to j$ 路径最大值。

只考虑某个保留特征的子集。求出最小生成树，树边自然满足，非树边也只需要考虑树上的路径了。

### CF438E. The Child and Binary Tree

抱歉不会 GF，考虑直接 CDQ 分治。

转移形如 $F=F^2G+1$。

$$
f_n=\sum_{i+j<n}f_if_jg_{n-i-j}
$$

- 当 $l=0$ 时，$f_{[l,\mathit{mid})}\times f_{[l,\mathit{mid})]}\times g_{[0,r-l)}$ 贡献到 $f_{[\mathit{mid},r)}$；
- 当 $l\neq 0$ 时，只有 $i,j$ 其中一个满足 $\in [l,\mathit{mid})$，$f_{[l,\mathit{mid})}\times f_{[0,r-l)}\times g_{[0,r-l)}$
贡献到 $f_{[\mathit{mid},r)}$。

### CF1111E. Tree

DP 难以子树合并，不妨按深度从小到大插入点，此时只需要关心他的祖先。

### CF1080F. Katya and Segments Sets

一个集合的话，扫描线枚举一个端点，另一个端点是否合法就是维护最值。主席树维护所有集合。

### CF802C. Heidi and Library (hard)

考虑图书馆每个单位空间，作为流量。

每个请求拆点，中间连 $-\infty$ 代价的边保证全部被经过。

每个请求向后面每个请求连边，同类代表延续，如果异类就带上相应代价换书。

跑最小费用最大流，答案再加上 $n\cdot -\infty$。

### UOJ#607. 【UR #20】跳蚤电话

倒序操作，每次删去叶子或者只有一个儿子的节点。求操作排列方案数。

转化为概率，可以避免麻烦的组合排列。设 $f_u$ 表示随机排列能够删光 $u$ 子树的概率。

从下往上 DP：$u$ 最后删，或者枚举一个子树 $v$ 最后删（$u$ 成为除 $v$ 子树以外最后删的），
$$
f_u=\frac{1}{\mathrm{size}_u}\left(\prod_{v\in\mathrm{son}_u}f_v+\sum_{v\in\mathrm{son}_u}f_v\cdot \mathrm{size}_v\cdot\prod_{w\in\mathrm{son}_u,w\neq v}f_w\cdot \frac{1}{\mathrm{size}_u-\mathrm{size}_v}\right).
$$

### UOJ#181. 【UR #12】密码锁

竞赛图缩点后是一条链。假设有 $c$ 个强连通分量，那么一定可以找出 $c$ 个非空子集 $S$，满足 $S$ 到 $U\setminus S$ 的所有边都是指向 $U\setminus S$ 的。

考虑每个割集的贡献。可以枚举割边是哪个子集但是后续处理复杂度会有点高。由于特殊边构成的连通块大小最大是 $m+1$，每个连通块分别处理，枚举 $S$ 集合后可以 $\mathcal O(m)$ 计算贡献。最后做背包合并贡献即可。$\mathcal O((n+2^{m+1})m+n^2)$。

### UOJ#370. 【UR #17】滑稽树上滑稽果

贪心考虑，最优策略是弄一条链，并且前若干个数能覆盖 $0$ 的并集。

后面的数的贡献是确定的，只考虑 DP 前面这些数的顺序。由于前面每个数必须使得当前交集大小减小，可以做子集 DP，$\mathcal O(3^{\log a})$。

### CF960G. Bandit Blues

只考虑一侧限制的话，从大往小放数，可以 DP：$s(N,A)=s(N-1,A-1)+(N-1)\cdot s(N-1,A)$，可以发现 $s(N,A)={N-1\brack A-1}$。

取最大值的位置，发现两侧的 bags 是不交的。答案也就是 $s(N,A+B-1)\times \binom{A+B-2}{A-1}$。

第一类斯特林数考虑求一行，根据 $x^{\overline n}=\sum_k{n\brack k}x^k$，可以分治乘法，也可以从 $f(x)$ 通过一次卷积处理出 $f(x+c)$ 来倍增。

### CF961G. Partitions

~~计算每个数的贡献，枚举其所在集合大小，可以得到 $\sum_i a_i\sum_{s=1}^ns\cdot\binom{n-1}{s-1}\cdot{n-s\brace k-1}$，然后求第二类斯特林数·列即可。~~

计算每个数的贡献，$|S|$ 的系数可以转化为，点对 $(i,j)$ 在同一集合中时，对 $a_i$ 有 $1$ 的贡献。

讨论 $i,j$ 是否相等，每个 $a_i$ 的贡献系数也就是

$$
{n\brace k}+(n-1){n-1\brace k}.
$$

单点求 ${n\brace k}$ 可以直接容斥。

### Luogu P5244 [USACO19FEB] Mowing Mischief P

容易得到朴素做法 $f_i\gets f_j+(x_i-x_j)(y_i-y_j)$。

首先按每个数结尾 LIS 长度分类，层层转移。

猜测有决策单调性，设两转移点 $j,k$，若 $j$ 比 $k$ 转移到 $i$ 优，可以得到

$$
(x_k-x_j)y_i+(y_k-y_j)x_i<f_k-f_j+x_jy_k-x_jy_j
$$

注意到同一层任意两点若 $x_j<x_k$ 则 $y_j>y_k$，那么上式的意义为：一条斜率为正的直线下方的半平面，$j$ 比 $k$ 更优。由此验证决策单调性，可以分治解决。

每个点的可转移点是一个区间，需要再套一层线段树分治。

### CF1239E. Turtle

假设分好了两个集合，两行肯定贪心的按递增、递减排序。

设 $w_i=a_{i+1}-b_i$，那么权值可以表示为 $a_1+\left(\sum_ib_i\right)+\max_{i=1}^{n-1}\{\mathrm{presum}(w)_i\}$。注意还要和 $a_1+(\sum_ib_i)$ 取 $\max$。

观察到 $w_i$ 单调增，那么一个划分的权值就是 $\max(a_1+\sum_ib_i,b_n+\sum_ia_i)$。

枚举 $a_1,b_n$ 之后是经典问题，可以背包。

所有数的最小值一定在 $a_1,b_n$ 中，假设是 $a_1$。次小值一定在 $a_2,b_n$ 中，发现调整至 $b_n$ 一定不劣。由此省去枚举，可以 $\mathcal O(n^2\sum a)$。

还可以 `std::bitset<>` 优化，逆推时暴力枚举前驱。


