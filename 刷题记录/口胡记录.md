调代码太累啦，耍点脾气。

## Luogu P3449 [POI2006]PAL-Palindromes

枚举拼接后较长的那个串，然后在上面枚举较小串长度，统计数量可以 trie 或者 hash，长串剩余部分再判一下回文。

胡完才发现有给出特殊性质：都是回文串。这样有个结论是，$AB$ 是回文串的充要条件是 $A,B$ 的最小循环节相同。因为回文串的最小循环节也是回文串。

至于这个结论怎么想的，估计是手完、猜、对拍吧。

## Luogu P3158 [CQOI2011]放棋子

异色子不能处于同行或同列，只要划分好每个颜色占有那些行列，不同颜色之间就是独立的。

大体上是做背包，$f(i,j,k)$ 表示 $i$ 行 $j$ 列放前 $k$ 个颜色的方案数。

每加入一个颜色的棋子，转移代价为 $g(i,j,k)$ 表示 $i$ 行 $j$ 列放 $k$ 个棋子，并且不留空行列的方案数。不留空行列，可以容斥满足。

## CF314E. Sereja and Squares

正解还真就是 $\mathcal O(n^2)$ 暴力 + 卡常，不适合口胡，[写了一发](https://codeforces.com/contest/314/submission/134666984)。

教训是要有梦想，适当对暴力卡常。

## CF685B. Kay and Snowflake

重心一定是从重儿子的转移而来，暴力移动。

## Luogu P5358 [SDOI2019]快速查询

维护全局加和乘的 tag，`std::unordered_map<>` 记录单点求修改，注意是相对值。

## Luogu P3451 [POI2007]ATR-Tourist Attractions

看起来是对每个 $2\dots k+1$ 为起点跑最短路，然后做一个 $\mathcal O(2^kk)$ 的状压 DP 就好啦。

但是状压会被卡空间，按状压集合大小分组，然后就可以滚动数组，空间复杂度就是 $\mathcal O(k{k\choose k/2})$ 啦。

或者想办法少压一位追求个 $\frac 1 2$ 的常数也是可以的。

## Luogu P4824 [USACO15FEB]Censoring S

似乎就是照题意模拟，KMP 或者 hash 来匹配。

## CF1043F. Make It One

做过的题怎么又不会了。

答案不超过 $7$，因为加入每一个数至少要去掉一个质因子。

那么枚举答案，选出 $k$ 个数使得 $\gcd=i$ 的方案数是好求的，求出倍数的答案然后容斥。

或者考虑万能的子集 DP，枚举每个数作为集合里第一个，然后划分质因子集合哪些由一个其他数消掉。需要对每个质因子集合，处理只包含集合的某个子集质因子的数的数量。

## Luogu P1084 [NOIP2012 提高组] 疫情控制

分配军队的策略不好明确，答案取决于时间最大值，先二分答案，然后每个军队的策略一定是贪心往根处走。

可能会有根的一些子树未被覆盖，一些多余的军队需要经过根来覆盖这些子树。能够到达根的那些军队是“自由的”，可能会覆盖其所在子树，也可能会覆盖根的其他子树。将未匹配的子树和军队都拎出来从小到大贪心配对即可。

## Luogu P3643 [APIO2016]划艇

值域很大，肯定是离散化后分段考虑。~~不寻常做法：因为每一段的答案是一个 $n$ 次多项式，分别拉格朗日插值好了。~~

然后似乎 ARC104E 的主要部分很像，不过多了一个下界，不好容斥。

DP 设 $f(i,j)$ 表示 $i$ 点结尾，已选最大值为第 $j$ 段的方案数。转移需要枚举最后连续 $k$ 个同属于第 $j$ 段的点，组合系数是 $\displaystyle {\mathrm{len}_j+k-1\choose k}$（$k-1$ 是不派出划艇的）。

复杂度 $\mathcal O(n^3)$。这个做法对 ARC104E 那题也是适用的。

## P3452 [POI2007]BIU-Offices

转化一下是求补图连通块数。

考虑整出补图每个连通块的生成树。用链表维护未加入生成树的点集，从某一个点开始 BFS，标记出边，遍历链表，删点入队。

每条边两边的点会被打一次标记并取消一次标记，并最多一次作为遍历链表时没有被删去的点；每个点会被删除一次。复杂度 $\mathcal O(n+m)$。

## Luogu P3188 [HNOI2007]梦幻岛宝珠

洛谷题解都讲的啥啊，乱七八糟的。

还是按体积从小到大处理背包，由于 $a\times 2^b$ 的物品体积性质，我们肯定是逐位的做。会发现，做第 $i$ 位所有物品的背包时，$m$ 中 $2^{i-1}$ 及以下的边角体积不再有用，只能由小的物品去占用。

那么记录的状态就是 $f(i,j)$ 表示处理完前 $i$ 位的物品后，$j\times 2^i+(m\bmod 2^i)$ 体积的最大价值。注意一下 $i$ 到 $i+1$ 位的转移。复杂度 $\mathcal O(an\log m)$。

## CF1166E. The LCMs Must be Large

如果存在两个区间无交则无解，比较显然。

否则一定有解，可以构造：取 $m$ 个质数 $p_1\dots p_m$，令集合 $i$ 的数都包含因子 $p_i$。那么因为集合两两有交，补集的 $\mathrm{lcm}$ 一定不超过 $\prod_jp_j$；而因为只有 $i$ 集合包含 $p_i$，所以 $i$ 集合 $\mathrm{lcm}>\prod_jp_j$。

判交用 $\texttt{std::bitset<>}$。


